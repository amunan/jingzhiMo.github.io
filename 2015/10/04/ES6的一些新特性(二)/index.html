<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6的一些新特性(二) | 主页</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇主要介绍了ES6的变量声明与变量的解构；这一篇主要说字符串，数值等等方面的扩展，因为这部分的API较多，所以对一些API并没有说到，只是对一部分进行说明。来来来，过来瞧瞧…
字符串的扩展ES6加强了对Unicode的支持，扩展了API;以前javascript的每个字符是固定两个字节的。在ES6，对于那些需要4个字符存储的字符(Unicode编号大于0xFFFF的字符)，Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6的一些新特性(二)">
<meta property="og:url" content="http://yoursite.com/2015/10/04/ES6的一些新特性(二)/index.html">
<meta property="og:site_name" content="主页">
<meta property="og:description" content="上一篇主要介绍了ES6的变量声明与变量的解构；这一篇主要说字符串，数值等等方面的扩展，因为这部分的API较多，所以对一些API并没有说到，只是对一部分进行说明。来来来，过来瞧瞧…
字符串的扩展ES6加强了对Unicode的支持，扩展了API;以前javascript的每个字符是固定两个字节的。在ES6，对于那些需要4个字符存储的字符(Unicode编号大于0xFFFF的字符)，Javascript">
<meta property="og:updated_time" content="2015-10-04T09:21:51.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6的一些新特性(二)">
<meta name="twitter:description" content="上一篇主要介绍了ES6的变量声明与变量的解构；这一篇主要说字符串，数值等等方面的扩展，因为这部分的API较多，所以对一些API并没有说到，只是对一部分进行说明。来来来，过来瞧瞧…
字符串的扩展ES6加强了对Unicode的支持，扩展了API;以前javascript的每个字符是固定两个字节的。在ES6，对于那些需要4个字符存储的字符(Unicode编号大于0xFFFF的字符)，Javascript">
  
    <link rel="alternative" href="/atom.xml" title="主页" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/image/kakaxi.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mo Jingzhi</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/jingzhiMo" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:mojingzhi.mail@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/balabala/" style="font-size: 10px;">balabala</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/入门/" style="font-size: 10px;">入门</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">找工作、找工作、找工作...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mo Jingzhi</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/image/kakaxi.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Mo Jingzhi</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jingzhiMo" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:mojingzhi.mail@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-ES6的一些新特性(二)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/04/ES6的一些新特性(二)/" class="article-date">
  	<time datetime="2015-10-04T09:18:48.000Z" itemprop="datePublished">2015-10-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6的一些新特性(二)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://jingzhimo.github.io/2015/09/29/ES6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/" target="_blank" rel="external">上一篇</a>主要介绍了ES6的变量声明与变量的解构；这一篇主要说字符串，数值等等方面的扩展，因为这部分的API较多，所以对一些API并没有说到，只是对一部分进行说明。来来来，过来瞧瞧…</p>
<h2 id="字符串的扩展">字符串的扩展</h2><p>ES6加强了对Unicode的支持，扩展了API;以前javascript的每个字符是固定两个字节的。在ES6，对于那些需要4个字符存储的字符(Unicode编号大于0xFFFF的字符)，Javascript会认为它们是两个字符。对正则的支持也增多了。</p>
<p>但是觉得最厉害的是，字符串增加了模版字符串，for example</p>
<pre><code><span class="comment">// 普通字符串</span>
`<span class="keyword">In</span> JavaScript <span class="keyword">is</span> a good.`
<span class="comment">// 多行字符串</span>
`<span class="keyword">In</span> ES5 JavaScript this <span class="keyword">is</span>
<span class="keyword">not</span> legal`
</code></pre><a id="more"></a>
<p>对于模版字符串，定义的方法就是使用两个反引号之间<code>(``)</code>，上面两个例子相比，可以多行使用，很是厉害，再看一个例子</p>
<pre><code><span class="comment">// 在字符串中嵌入变量</span>
<span class="keyword">var</span> h = <span class="string">'hello'</span>,
    w = <span class="string">'world'</span>;
<span class="keyword">var</span> str = <span class="string">`<span class="subst">${h}</span> - <span class="subst">${w}</span>`</span>;

<span class="built_in">console</span>.log(str); <span class="comment">// 'hello - world'</span>
</code></pre><p>这个功能很是不错，把变量用<code>${}</code>包围起来，就可以使用了，这样就可以不用一个字符串一个字符串的相加，还可以多行使用，可以可以!</p>
<h2 id="数值的扩展">数值的扩展</h2><p>在数值<code>(Number)</code>方面，新增加的特性不算多，但是多了很多的API，关于数学计算的也很多。</p>
<p>在二进制和八进制表示方面，调整了一下，分别使用前缀<code>0b</code>和<code>0o</code>来表示二进制和八进制；而十六进制也是用之前的<code>0x</code>；例如：</p>
<pre><code><span class="number">0</span>b111 === <span class="number">7</span> <span class="comment">// true</span>
<span class="number">0</span>o11 === <span class="number">9</span> <span class="comment">// true</span>
</code></pre><p>这里说一下<code>parseInt()</code>和<code>parseFloat()</code>的两个方法；ES6把这个两个方法移植到<code>Number</code>对象上面，行为保持不变，但是原来全局的方法还是存在；这样做也是为了减少全部性方法，使得语言逐步模块化。嗯```</p>
<h2 id="数组的扩展">数组的扩展</h2><p>数组也扩展了很多有用的API，很实在.嗯.</p>
<h3 id="Array-from()">Array.from()</h3><p>把类数组对象（如：<code>arguments</code>、<code>querySelectorAll</code>方法返回的对象）和可遍历对象(<code>iterable</code>后面会说到)，这两种对象转化为数组。</p>
<pre><code><span class="comment">// 以前，我们把`arguments`转化为数组对象，通常是这样做的：</span>
<span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);
<span class="comment">// 现在我们可以这样</span>
<span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);
</code></pre><h3 id="Array-fill()">Array.fill()</h3><p>使用给定值填充一个数组</p>
<p>假设我们要初始化一个长度为10的数组，元素全为0；我就会用个<code>for</code>循环来一个一个，一个一个的赋值…而<code>fill</code>方法可以更加明确的赋值：</p>
<pre><code><span class="comment">// 把一个数组初始化全部为1</span>
var arr = <span class="keyword">new</span> Array(<span class="number">100</span>);
arr.fill(<span class="number">1</span>);
</code></pre><h3 id="数组推导">数组推导</h3><p>ES6允许通过已经存在的数组生成新的数组; such as</p>
<pre><code>var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var newArr = [<span class="keyword">for</span> (i of arr) i * <span class="number">2</span>];
newArr <span class="comment">// [2,4,6,8];</span>
</code></pre><p>不过要注意的是，<code>for...of</code>结构总是写在最前面，返回的表达式写在最后面，；还可以附加<code>if</code>语句…</p>
<pre><code>var arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var newArr2 = [<span class="keyword">for</span> (i of arr2) <span class="keyword">if</span>(i % <span class="number">2</span>) i];
newArr2 <span class="comment">// [1,3]</span>
</code></pre><p>另外，由于新数组会立即在内存中生成，这时，如果原数组是一个很大的数组，将非常耗费内存。</p>
<h2 id="对象的扩展">对象的扩展</h2><h3 id="增强的对象写法">增强的对象写法</h3><pre><code><span class="keyword">var</span> Person = {
    name: <span class="string">'kevin'</span>,

    <span class="comment">// 相当于birth: birth</span>
    birth,

    <span class="comment">// 相当于sayHello: function() {//...}</span>
    sayHello() {
        <span class="built_in">console</span>.log(<span class="string">'my name is'</span> + <span class="keyword">this</span>.name);
    }
};

<span class="comment">// 用于函数返回值还是不错的</span>
<span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>{
    <span class="keyword">var</span> x = <span class="number">1</span>,
        y = <span class="number">2</span>;

    <span class="keyword">return</span> {x,y};
    <span class="comment">// 相当于：{x: x, y: y];</span>
};
<span class="keyword">var</span> point = getPoint(); <span class="comment">// {x: 1, y: 2};</span>
</code></pre><h3 id="属性名表达式">属性名表达式</h3><p>对象的属性名，可以通过表达式的计算，来计算出属性名，表达式要放在<code>[]</code>里面</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="string">'yy'</span>;
};
<span class="keyword">var</span> z = <span class="string">'zz'</span>;
<span class="keyword">var</span> obj = {
    xx: <span class="number">1</span>,
    [y()]: <span class="number">2</span>,
    [z]: <span class="number">3</span>
};
<span class="built_in">console</span>.log(obj); <span class="comment">// {x: 1, y: 2, zz: 3};</span>
</code></pre><h3 id="新增原始数据类似Symbol">新增原始数据类似Symbol</h3><p>通过<code>Symbol()</code>的函数生成：</p>
<pre><code><span class="keyword">var</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'hello'</span>);
<span class="keyword">typeof</span> symbol <span class="comment">// 'symbol'</span>
</code></pre><p>很明显，<code>symbol</code>是一个基本数据类型，通过直接调用构造函数即可，传入字符串生成；不能使用<code>new</code> 来生成；Symbol 最大的特点就是可以生成一个独一无二的值；可以用于标识符，保证属性名之间不会发生冲突</p>
<pre><code><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'str'</span>)
    s2 = <span class="built_in">Symbol</span>(<span class="string">'str'</span>);
s1 === s2 <span class="comment">// false</span>
</code></pre><h3 id="代理Proxy">代理Proxy</h3><p>可以理解为在目标对象进行操作的时候，先进行拦截与过滤，再返回。ES6 提供Proxy构造函数，用来生成proxy对象</p>
<p>下面是对<code>person</code>对象的修改与查询属性的操作进行拦截，具体其他操作，可以看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">MDN的文档</a></p>
<pre><code><span class="keyword">var</span> person = {
    name: <span class="string">'kevin'</span>,
    age: <span class="number">22</span>
};
<span class="keyword">var</span> handler = {
    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, val</span>) </span>{
        <span class="keyword">if</span>(target[prop] === <span class="literal">undefined</span>) {

            <span class="built_in">console</span>.log(prop + <span class="string">'is undefined'</span>);
        } <span class="keyword">else</span> {
            target[prop] = val;
        }
    },
    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>{
        <span class="keyword">if</span>(target[prop] === <span class="literal">undefined</span>) {

            <span class="built_in">console</span>.log(prop + <span class="string">'is undefined'</span>);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> target[prop];
        }
    }
};
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, handler);
person.age = <span class="number">21</span>;             <span class="comment">// successful</span>
<span class="built_in">console</span>.log(person);         <span class="comment">// {name: "kevin", age: 21}</span>
person.a = <span class="number">1</span>;                <span class="comment">// a is undefined</span>
<span class="built_in">console</span>.log(person.name);    <span class="comment">// "kevin"</span>
<span class="built_in">console</span>.log(person.b);        <span class="comment">// b is undefined</span>
</code></pre><h2 id="函数的扩展">函数的扩展</h2><h3 id="rest参数与扩展运算符(spread)">rest参数与扩展运算符(spread)</h3><p>ES6引入了rest参数(…变量名)，用于获取函数多余的参数,举个栗子</p>
<pre><code><span class="comment">// push函数传入一个数组，还有需要添加到该数组的元素</span>
<span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(arr, <span class="rest_arg">...items</span>)</span> </span>{

    <span class="keyword">for</span>(let item of items) {

        arr.push(item);
    }
}
<span class="keyword">var</span> arr = [];
push(arr, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);
arr <span class="comment">// [1,2,3]</span>
</code></pre><p><code>items</code>是一个数组，接收函数参数列表剩余的所有参数，因此，rest参数只能够放在函数参数列表的最后，否则会报错</p>
<p>三个点(…)是扩展运算符，刚好与rest参数的用法相反，可以把一个数组转化成一个一个的元素…</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>{
    <span class="keyword">return</span> x + y;
}
<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];
add(...arr); <span class="comment">// 3</span>

<span class="comment">// 求数组最大元素</span>
<span class="comment">// ES5</span>
<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);
<span class="comment">// ES6</span>
<span class="built_in">Math</span>.max(...arr);
<span class="comment">// 相当于</span>
<span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);
</code></pre><h3 id="箭头函数">箭头函数</h3><p>通过使用“箭头”(<code>=&gt;</code>)来定义函数.</p>
<pre><code><span class="keyword">var</span> func = arg =&gt; arg;
<span class="comment">// 上面的函数相当于</span>
<span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>{
    <span class="built_in">console</span>.log(arg);
};
</code></pre><p>炫酷！</p>
<p>箭头函数不需要参数，或者参数个数大于一个，就使用一对圆括号来代表参数部分：</p>
<pre><code><span class="comment">// 没有参数</span>
<span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="params">()</span></span> =&gt; {<span class="keyword">return</span> <span class="literal">true</span>;} 
<span class="comment">// 刚才忘记说，如果多个语句，就需要花括号括起来，并且使用return语句返回</span>
<span class="comment">// 多个参数</span>
<span class="keyword">var</span> <span class="func"><span class="keyword">func</span> = <span class="params">(arg1, arg2)</span></span> {<span class="keyword">return</span> arg1 + arg2;}
</code></pre><p>如果需要返回一个对象的话，必须在对象外面加上括号：</p>
<pre><code><span class="keyword">var</span> getItem = id =&gt; ({id: id, name: <span class="string">'haha'</span>});
</code></pre><p>不过箭头函数还是与用<code>function</code>定义的函数不同：</p>
<ul>
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li>
<li>不可以使用arguments对象，该对象在函数体内不存在</li>
</ul>
<p>下面看一个例子，关于第一条不同的说明</p>
<pre><code><span class="keyword">var</span> handler = {
    id: <span class="string">'123456'</span>,
    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, 
                                  event =&gt; <span class="keyword">this</span>.doSomething(event.type), 
                                  <span class="literal">false</span>);
    },
    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"handling "</span> + type + <span class="string">"for"</span> + <span class="keyword">this</span>.id);
    }
};
</code></pre><p>在init方法中，事件处理的方法使用了箭头函数，因此这个时候的this就绑定在handler对象上面。否则，doSomething方法内部的this对象就指向全局对象，运行时会报错。</p>
<p>由于this在箭头函数顶被绑定，所以不能用<code>call()</code>,<code>apply()</code>, <code>bind()</code>这些方法去改变this的指向。</p>
<h2 id="数据结构的扩展:_Set和Map">数据结构的扩展: Set和Map</h2><p>在ES5，javascript主要用到的数据结构是数组。ES6增加了两种: <code>Set</code>和<code>Map</code></p>
<h3 id="Set">Set</h3><p>Set类似数组，只不过成员值是唯一，没有重复的值，没有重复的值，没有重复的值。重要的事情要说三遍。</p>
<p>向Set加入值的时候，不会发生类型转换，5和”5”是两个不同的值。</p>
<pre><code>var <span class="operator"><span class="keyword">set</span> = <span class="keyword">new</span> <span class="keyword">Set</span>();</span>
<span class="operator"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="number">1</span>);</span> // <span class="operator"><span class="keyword">Set</span> { <span class="number">1</span> }
<span class="keyword">set</span>.<span class="keyword">add</span>(<span class="number">2</span>);</span> // <span class="operator"><span class="keyword">Set</span> { <span class="number">1</span>, <span class="number">2</span> }
<span class="keyword">set</span>.<span class="keyword">add</span>(<span class="number">2</span>);</span> // <span class="operator"><span class="keyword">Set</span> { <span class="number">1</span>, <span class="number">2</span> }，也是一样，不会增加</span>
</code></pre><p>Set也可以通过数组来初始化</p>
<pre><code>var <span class="built_in">set</span> = <span class="keyword">new</span> Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]);
<span class="built_in">set</span> <span class="comment">// Set { 1, 2, 3, 4 }，也会过滤掉相同的值，这个特性可以去除数组重复的值</span>
</code></pre><p>Set 主要拥有的属性和方法如下：</p>
<ul>
<li>size: 返回Set的成员总算，注意，Set是用size来返回长度的，不是length</li>
<li>add(value): 添加值</li>
<li>delete(value): 删除值</li>
<li>has(value): 是否包含该值，返回布尔值</li>
<li>clear(): 清除所有成员</li>
</ul>
<h2 id="Map">Map</h2><p>尽管使用对象也可以模拟出Map，但是由于对象的键名，只能是字符串，而且，有时候对象还继承于其他对象，也会造成不必要的错误；而 Map不仅仅可以用字符串做键名，对象也可以做键名，对象…这。在javascript几乎所有东西都是对象的情况下，基本所有东西都可以做键名了.那个null,undefined也可以.</p>
<pre><code><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();
<span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(<span class="string">'name'</span>, <span class="string">'kevin'</span>);
<span class="built_in">var</span> obj = {x: <span class="number">1</span>};
<span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(obj, <span class="string">'this is object'</span>);
console<span class="built_in">.</span><span class="keyword">log</span>(<span class="built_in">map</span><span class="built_in">.</span>get(obj)); <span class="comment">// 'this is object'，obj就是一个键名</span>
</code></pre><p>Map也可以接收一个数组进行初始化，但是数组的格式要注意一下：</p>
<pre><code>var arr = [[<span class="string">"x"</span>, <span class="number">1</span>], [<span class="string">"y"</span>, <span class="number">2</span>]];
var <span class="built_in">map</span> = <span class="keyword">new</span> Map(arr);
console.<span class="built_in">log</span>(<span class="built_in">map</span>); <span class="comment">// Map { 'x' =&gt; 1, 'y' =&gt; 2 }</span>
</code></pre><p>Map 主要拥有的属性和方法如下：</p>
<ul>
<li>size: 返回成员的总数，注意不是length</li>
<li>set(key, value): 设置键值对</li>
<li>get(key): 通过键名获取值</li>
<li>has(key): 是否包含该键名的值</li>
<li>delete(key): 通过键名删除</li>
<li>clear(): 清楚所有成员</li>
</ul>
<p>Map的遍历方法</p>
<ul>
<li>keys(): 返回键名的遍历器</li>
<li>values(): 返回剑指的遍历器</li>
<li>entries(): 返回所有成员的遍历器</li>
</ul>
<p>keys() 使用示例：</p>
<pre><code><span class="keyword">for</span>(let <span class="variable">key</span> of <span class="built_in">map</span>.keys()) {
    console.<span class="built_in">log</span>(<span class="string">"key is:"</span> + <span class="variable">key</span>);
]
</code></pre><p>values()与keys() 基本一致</p>
<p>entries() 使用示例：</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">let</span> <span class="literal">item</span> <span class="keyword">of</span> <span class="keyword">map</span>.entries()) {
    console.log(<span class="string">'key:'</span> + item[<span class="number">0</span>] + <span class="string">' values: '</span> + item[<span class="number">1</span>]);
}
</code></pre><h2 id="最后">最后</h2><p>篇幅有点少长…有错误可以戳一些<a href="https://github.com/jingzhiMo/jingzhiMo.github.io" target="_blank" rel="external">在这里</a>，麻烦提一下issue…写到肚子饿了；吃饭去了。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/08/ES6的一些特性(三)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          ES6的一些特性(三)
        
      </div>
    </a>
  
  
    <a href="/2015/09/29/ES6的一些新特性(一)/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ES6的一些新特性(一)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Mo Jingzhi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>